<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>3D Nested Cubes Rotation</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
     const canvas = document.getElementById("canvas");
     const ctx = canvas.getContext("2d");
     canvas.width = window.innerWidth;
     canvas.height = window.innerHeight;

     // Global rotation angles (in radians)
     let rotX = 0;
     let rotY = 0;
     const sensitivity = 0.005; // mouse sensitivity

     // When the mouse moves, update rotation angles relative to canvas center
     canvas.addEventListener("mousemove", (e) => {
         const centerX = canvas.width / 2;
         const centerY = canvas.height / 2;
         // Update rotY with vertical movement and rotX with horizontal movement.
         rotY = (e.clientX - centerX) * sensitivity;
         rotX = (e.clientY - centerY) * sensitivity;
     });

     // Basic 3D rotation functions
     function rotateX(point, angle) {
         return {
             x: point.x,
             y: point.y * Math.cos(angle) - point.z * Math.sin(angle),
             z: point.y * Math.sin(angle) + point.z * Math.cos(angle)
         };
     }
     function rotateY(point, angle) {
         return {
             x: point.x * Math.cos(angle) + point.z * Math.sin(angle),
             y: point.y,
             z: -point.x * Math.sin(angle) + point.z * Math.cos(angle)
         };
     }
     function rotatePoint(point, angleX, angleY) {
         let p = rotateX(point, angleX);
         p = rotateY(p, angleY);
         return p;
     }

     // Perspective projection function
     // Using a simple perspective where d is the distance to the projection plane.
     const d = 200;
     function project(point) {
         const scale = d / (point.z + d);
         return {
             x: point.x * scale + canvas.width / 2,
             y: -point.y * scale + canvas.height / 2  // Note: invert y so that positive y is up.
         };
     }

     // Define cube vertices for a cube centered at origin.
     // A cube of "1 cmÂ³" scaled to screen units. We'll use arbitrary size (e.g. 50 pixels for smallest)
     function getCubeVertices(size) {
         const s = size / 2;
         return [
             { x: -s, y: -s, z: -s }, // v0
             { x:  s, y: -s, z: -s }, // v1
             { x:  s, y:  s, z: -s }, // v2
             { x: -s, y:  s, z: -s }, // v3
             { x: -s, y: -s, z:  s }, // v4
             { x:  s, y: -s, z:  s }, // v5
             { x:  s, y:  s, z:  s }, // v6
             { x: -s, y:  s, z:  s }  // v7
         ];
     }

     // Define the cube faces by indices into the vertices array.
     // We'll draw the front face (v0,v1,v2,v3) only when not rotated; however, here we want all 3D effects.
     // For simplicity, we'll draw all edges.
     const cubeEdges = [
         [0, 1], [1, 2], [2, 3], [3, 0], // front face
         [4, 5], [5, 6], [6, 7], [7, 4], // back face
         [0, 4], [1, 5], [2, 6], [3, 7]  // connecting edges
     ];

     // Cubes: three nested cubes with different sizes and different rotation speed multipliers.
     const cubes = [
         { size: 50, speedMultiplier: 1.0, color: "#FF0000" },
         { size: 70, speedMultiplier: 0.7, color: "#00FF00" },
         { size: 90, speedMultiplier: 0.4, color: "#0000FF" }
     ];

     // Draw a single cube: apply 3D rotations (scaled by the cube's speed multiplier) and project vertices.
     function drawCube(cube) {
         const vertices = getCubeVertices(cube.size);
         // For each vertex, apply rotation.
         const rotated = vertices.map(v => rotatePoint(v, rotX * cube.speedMultiplier, rotY * cube.speedMultiplier));
         // Then project them.
         const projected = rotated.map(v => project(v));
         // Draw edges.
         ctx.strokeStyle = cube.color;
         ctx.lineWidth = 3;
         ctx.beginPath();
         cubeEdges.forEach(edge => {
             const [i1, i2] = edge;
             const p1 = projected[i1];
             const p2 = projected[i2];
             ctx.moveTo(p1.x, p1.y);
             ctx.lineTo(p2.x, p2.y);
         });
         ctx.stroke();
     }

     function draw() {
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         // Draw each cube (from outermost to innermost so inner cube appears on top)
         cubes.forEach(cube => drawCube(cube));
         requestAnimationFrame(draw);
     }

     draw();

     window.addEventListener("resize", () => {
         canvas.width = window.innerWidth;
         canvas.height = window.innerHeight;
     });
    </script>
  </body>
</html>
