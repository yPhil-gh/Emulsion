<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>80s Sunset Scene with Gradient</title>
        <style>
         html, body {
             margin: 0;
             padding: 0;
             overflow: hidden;
             background: black;
         }
         canvas {
             display: block;
         }
        </style>
    </head>
    <body>
        <svg id="logo-source" style="display:none">
            <!-- E -->
            <path id="e1" d="M 20 20 L 60 20 M 20 50 L 60 50 M 20 80 L 60 80 M 20 20 L 20 80
                      M 20 20 Q 20 20, 22 22 M 60 20 Q 60 20, 62 22
                      M 20 50 Q 20 50, 22 52 M 60 50 Q 60 50, 62 52
                      M 20 80 Q 20 80, 22 82 M 60 80 Q 60 80, 62 82"/>

            <!-- m (normal) -->
            <path id="m1" d="M 120 20 L 120 80 M 160 20 L 160 80
                      M 120 50 Q 140 35, 160 50
                      M 120 20 Q 120 20, 122 22 M 160 20 Q 160 20, 162 22
                      M 120 50 Q 120 50, 122 52 M 160 50 Q 160 50, 162 52
                      M 140 35 Q 140 35, 142 37"/>

            <!-- u (orange) -->
            <path id="u" d="M 220 20 L 220 80 M 260 20 L 260 80 M 220 80 L 260 80
                      M 220 20 Q 220 20, 222 22 M 260 20 Q 260 20, 262 22
                      M 220 80 Q 220 80, 222 82 M 260 80 Q 260 80, 262 82"/>

            <!-- m (horizontal flip) -->
            <path id="m2" d="M 320 20 L 320 80 M 360 20 L 360 80
                      M 320 50 Q 340 65, 360 50
                      M 320 20 Q 320 20, 322 22 M 360 20 Q 360 20, 362 22
                      M 320 50 Q 320 50, 322 52 M 360 50 Q 360 50, 362 52
                      M 340 65 Q 340 65, 342 67"/>

            <!-- E (vertical flip) -->
            <path id="e2" d="M 420 80 L 460 80 M 420 50 L 460 50 M 420 20 L 460 20
                      M 460 80 L 460 20
                      M 420 80 Q 420 80, 422 82 M 460 80 Q 460 80, 462 82
                      M 420 50 Q 420 50, 422 52 M 460 50 Q 460 50, 462 52
                      M 420 20 Q 420 20, 422 22 M 460 20 Q 460 20, 462 22"/>
        </svg>

        <canvas id="canvas"></canvas>
        <script>
         const canvas = document.getElementById('canvas');
         const ctx = canvas.getContext('2d');
         let width = canvas.width = window.innerWidth;
         let height = canvas.height = window.innerHeight;
         const horizon = height * 2 / 3;
         let mouseX = 0, mouseY = 0;

         // ðŸ”¥ SUN CONFIGURATION
         const SUN_BASE_RADIUS = 120; // Doubled from original 60
         const GLOW_SCALE = 6; // Increased from 4
         let sunYOffset = 0; // Added for vertical movement
         const SUN_SPEED = 0.9; // Pixels per frame
         const MAX_SUN_TRAVEL = height - horizon - 100; // Stop when logo reaches 100px from top

         // Logo configuration
         const LOGO_TEXT = "EmumÃˆ";
         const LOGO_SCALE = 8;
         let logoY = height + 100; // Start below screen
         let logoRotation = 0;
         let shimmerPhase = 0;
         let logoChars = [];

         // Logo configuration
         const LOGO_FINAL_Y = 100;

         // Pixel font data (7-segment style)
         const pixelFont = {
             'E': [[0,0],[4,0],[0,3],[4,3],[0,6],[4,6]],
             'm': [[0,0],[0,6],[2,3],[4,0],[4,6]],
             'u': [[0,6],[4,6],[4,0]],
             'Ãˆ': [[4,0],[0,0],[0,3],[4,3],[0,6],[4,6]] // Inverted E
         };

         // ============================
         // STARFIELD (top half)
         // ============================
         const starCount = 200;
         let stars = [];
         let shootingStars = [];
         for (let i = 0; i < starCount; i++) {
             stars.push({
                 x: Math.random() * width,
                 y: Math.random() * horizon,
                 size: Math.random() * 1.5 + 0.5,
                 speed: Math.random() * 0.2 + 0.05,
                 opacity: Math.random() * 0.5 + 0.5
             });
         }

         function spawnShootingStar() {
             if (shootingStars.length < 1 && Math.random() < 0.005) {
                 shootingStars.push({
                     x: Math.random() * width,
                     y: Math.random() * horizon * 0.5,
                     len: Math.random() * 80 + 80,
                     speed: Math.random() * 10 + 10,
                     angle: Math.PI / 4,
                     life: 0,
                     maxLife: 30 + Math.random() * 30
                 });
             }
         }

         function updateStars() {
             for (let star of stars) {
                 star.x -= star.speed;
                 if (star.x < 0) star.x = width;
             }
         }

         function updateShootingStars() {
             for (let i = shootingStars.length - 1; i >= 0; i--) {
                 let s = shootingStars[i];
                 s.x += s.speed * Math.cos(s.angle);
                 s.y += s.speed * Math.sin(s.angle);
                 s.life++;
                 if (s.life > s.maxLife) {
                     shootingStars.splice(i, 1);
                 }
             }
         }

         function drawStars() {
             ctx.fillStyle = "white";
             for (let star of stars) {
                 ctx.globalAlpha = star.opacity;
                 ctx.beginPath();
                 ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                 ctx.fill();
             }
             ctx.globalAlpha = 1;
         }

         function drawShootingStars() {
             ctx.strokeStyle = "white";
             ctx.lineWidth = 2;
             for (let s of shootingStars) {
                 ctx.beginPath();
                 ctx.moveTo(s.x, s.y);
                 ctx.lineTo(s.x - s.len * Math.cos(s.angle), s.y - s.len * Math.sin(s.angle));
                 ctx.stroke();
             }
         }


         // =======================[UPDATED SUN SYSTEM]=======================
         function updateSunPosition() {
             sunYOffset += SUN_SPEED; // Gradually lower the sun
         }

         function drawSun() {
             const sunX = width / 2;
             const sunY = horizon + sunYOffset; // ðŸ”¥ Now moves downward

             // ðŸ”¥ Enhanced glow with dynamic positioning
             const gradient = ctx.createRadialGradient(
                 sunX, sunY, SUN_BASE_RADIUS * 0.3,
                 sunX, sunY, SUN_BASE_RADIUS * GLOW_SCALE
             );
             gradient.addColorStop(0, 'rgba(255, 69, 0, 0.5)');
             gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.25)');
             gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

             // Draw glow first
             ctx.fillStyle = gradient;
             ctx.beginPath();
             ctx.rect(0, 0, width, height); // ðŸ”¥ Full height glow
             ctx.fill();

             // Main sun body (now larger)
             ctx.beginPath();
             ctx.arc(sunX, sunY, SUN_BASE_RADIUS, Math.PI, 2 * Math.PI);
             let sunGradient = ctx.createLinearGradient(0, sunY - SUN_BASE_RADIUS, 0, sunY);
             sunGradient.addColorStop(0, "#FF4500");
             sunGradient.addColorStop(1, "#FFD700");
             ctx.fillStyle = sunGradient;
             ctx.fill();

             // Sun details (scaled appropriately)
             const numLines = 8; // ðŸ”¥ Increased lines for bigger sun
             for (let i = 0; i < numLines; i++) {
                 let lineY = sunY - SUN_BASE_RADIUS + (i + 1) * (SUN_BASE_RADIUS / (numLines + 1));
                 ctx.beginPath();
                 let dx = Math.sqrt(SUN_BASE_RADIUS ** 2 - (sunY - lineY) ** 2);
                 ctx.moveTo(sunX - dx, lineY);
                 ctx.lineTo(sunX + dx, lineY);
                 ctx.lineWidth = 1 + (i / numLines) * 5; // ðŸ”¥ Thicker lines
                 ctx.strokeStyle = "rgba(0,0,0,0.3)";
                 ctx.stroke();
             }
         }

         // ============================
         // NEW: SUN GLOW GRADIENT
         // ============================
         function drawSunGlow() {
             const sunX = width / 2;
             const sunY = horizon;
             const sunRadius = 60;

             // Create radial gradient
             const gradient = ctx.createRadialGradient(
                 sunX, sunY, sunRadius * 0.3,
                 sunX, sunY, sunRadius * 4
             );
             gradient.addColorStop(0, 'rgba(255, 69, 0, 0.4)');
             gradient.addColorStop(0.7, 'rgba(255, 215, 0, 0.2)');
             gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

             // Draw gradient
             ctx.fillStyle = gradient;
             ctx.beginPath();
             ctx.rect(0, 0, width, horizon);
             ctx.fill();
         }


         // ============================
         // GRID SYSTEM WITH STABLE RELIEF
         // ============================
         const numGridLines = 40;
         const numGridCols = 30;
         const gridSpeed = 0.08;
         let gridOffset = 0;

         // Relief pattern storage
         const reliefMap = Array(numGridCols + 1).fill().map(() =>
             Array(numGridLines).fill().map(() =>
                 Math.random() < 0.12 ? Math.random() * 35 + 15 : 0
             )
         );

         function drawGrid() {
             ctx.strokeStyle = "#00FFFF";
             ctx.lineWidth = 1;

             // Calculate horizontal positions with seamless wrap
             const horizontalPositions = Array(numGridLines).fill().map((_, i) => {
                 const t = (i + gridOffset) % numGridLines;
                 const perspective = t / numGridLines;
                 return {
                     yBase: horizon + (height - horizon) * Math.pow(perspective, 2),
                     t: perspective
                 };
             });

             // Draw vertical lines with coordinated relief and fading
             const roadHalfWidth = 180;
             for (let col = 0; col <= numGridCols; col++) {
                 const xNorm = col / numGridCols;
                 const vanishX = width/2 - roadHalfWidth + xNorm * 2 * roadHalfWidth;

                 let lastPoint = null;

                 horizontalPositions.forEach((pos, row) => {
                     const lift = reliefMap[col][row];
                     const y = pos.yBase - lift;
                     const x = xNorm * width + (vanishX - xNorm * width) * (1 - pos.t);

                     if (row === 0) {
                         lastPoint = { x, y };
                     } else {
                         // Calculate alpha based on current row's t
                         let baseAlpha;
                         if (pos.t < 0.1) {
                             baseAlpha = 0;
                         } else if (pos.t < 0.3) {
                             baseAlpha = (pos.t - 0.1) / 0.2;
                         } else if (pos.t <= 0.7) {
                             baseAlpha = 1;
                         } else if (pos.t < 0.9) {
                             baseAlpha = 1 - (pos.t - 0.7) / 0.2;
                         } else {
                             baseAlpha = 0;
                         }
                         ctx.globalAlpha = baseAlpha * 0.6;

                         const cpX = (lastPoint.x + x) / 2;
                         const cpY = (lastPoint.y + y) / 2 - lift * 0.4;

                         ctx.beginPath();
                         ctx.moveTo(lastPoint.x, lastPoint.y);
                         ctx.quadraticCurveTo(cpX, cpY, x, y);
                         ctx.stroke();

                         lastPoint = { x, y };
                     }
                 });
             }

             // Draw horizontal lines with connected relief and fading
             horizontalPositions.forEach((pos, row) => {
                 // Calculate alpha based on row's t
                 let baseAlpha;
                 if (pos.t < 0.1) {
                     baseAlpha = 0;
                 } else if (pos.t < 0.3) {
                     baseAlpha = (pos.t - 0.1) / 0.2;
                 } else if (pos.t <= 0.7) {
                     baseAlpha = 1;
                 } else if (pos.t < 0.9) {
                     baseAlpha = 1 - (pos.t - 0.7) / 0.2;
                 } else {
                     baseAlpha = 0;
                 }
                 ctx.globalAlpha = baseAlpha * 0.6;

                 ctx.beginPath();
                 let lastX = null, lastY = null;

                 for (let col = 0; col <= numGridCols; col++) {
                     const xNorm = col / numGridCols;
                     const vanishX = width/2 - roadHalfWidth + xNorm * 2 * roadHalfWidth;
                     const lift = reliefMap[col][row];
                     const y = pos.yBase - lift;
                     const x = xNorm * width + (vanishX - xNorm * width) * (1 - pos.t);

                     if (col === 0) {
                         ctx.moveTo(x, y);
                         lastX = x;
                         lastY = y;
                     } else {
                         const cpX = (lastX + x) / 2;
                         const cpY = (lastY + y) / 2 - lift * 0.3;
                         ctx.quadraticCurveTo(cpX, cpY, x, y);
                         lastX = x;
                         lastY = y;
                     }
                 }
                 ctx.stroke();
             });

             ctx.globalAlpha = 1;
         }



         // Initialize character transformations
         function initLogo() {
             logoChars = [
                 { type: 'E', x: 40, flip: false },
                 { type: 'm', x: 120, flip: false },
                 { type: 'u', x: 200, flip: false },
                 { type: 'm', x: 280, flip: true },  // Horizontally flipped
                 { type: 'E', x: 360, flip: true }     // Vertically flipped
             ];
         }

         // Keep original starfield and grid code unchanged
         // ... [All previous starfield and grid code here] ...

         // In drawLogo() function:
         function drawLogo() {
             const scale = 1.5;
             const baseX = width/2 - 120; // Center 500px wide logo

             ctx.save();
             ctx.translate(baseX, logoY);
             ctx.scale(scale, scale);

             // Draw cyan elements
             ctx.strokeStyle = '#00FFFF';
             ctx.lineWidth = 3;
             ['e1', 'm1', 'm2', 'e2'].forEach(id => {
                 const path = new Path2D(document.getElementById(id).getAttribute('d'));
                 ctx.stroke(path);
             });

             // Draw orange u
             ctx.strokeStyle = '#FFA500';
             const uPath = new Path2D(document.getElementById('u').getAttribute('d'));
             ctx.stroke(uPath);

             ctx.restore();
         }

         function updateLogoPosition() {
             const travelRatio = sunYOffset / MAX_SUN_TRAVEL;
             logoY = height + 200 - (height - LOGO_FINAL_Y + 200) * travelRatio;
             if(sunYOffset >= MAX_SUN_TRAVEL) logoY = LOGO_FINAL_Y;
         }

         function update() {
             gridOffset += gridSpeed;
             if(gridOffset > numGridLines) gridOffset = 0;
             updateStars();
             updateShootingStars();
             spawnShootingStar();

             if(sunYOffset < MAX_SUN_TRAVEL) sunYOffset += SUN_SPEED;
             updateLogoPosition();
         }

         function draw() {
             ctx.clearRect(0, 0, width, height);

             // Background elements
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, 0, width, horizon);
             drawStars();
             drawShootingStars();
             drawSun();
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, horizon, width, height - horizon);
             drawGrid();

             // Foreground logo
             drawLogo();
         }

         function update() {
             gridOffset += gridSpeed;
             if(gridOffset > numGridLines) gridOffset = 0;
             updateStars();
             updateShootingStars();
             spawnShootingStar();

             if(sunYOffset < MAX_SUN_TRAVEL) sunYOffset += SUN_SPEED;
             updateLogoPosition();
         }

         function draw() {
             ctx.clearRect(0, 0, width, height);

             // Background elements
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, 0, width, horizon);
             drawStars();
             drawShootingStars();
             drawSun();
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, horizon, width, height - horizon);
             drawGrid();

             // Foreground logo
             drawLogo();
         }

         // Mouse listeners
         canvas.addEventListener('mousemove', (e) => {
             mouseX = e.clientX;
             mouseY = e.clientY;
         });

         function loop() {
             update();
             draw();
             requestAnimationFrame(loop);
         }

         initLogo();
         loop();

         window.addEventListener('resize', () => {
             width = canvas.width = window.innerWidth;
             height = canvas.height = window.innerHeight;
             horizon = height * 2/3;
             sunYOffset = 0;
             logoY = height + 200;
             initLogo();
         });

        </script>
    </body>
</html>
