<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>80s Sunset Scene with Gradient</title>
        <style>
         html, body {
             margin: 0;
             padding: 0;
             overflow: hidden;
             background: black;
         }
         canvas {
             display: block;
         }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>
         const canvas = document.getElementById('canvas');
         const ctx = canvas.getContext('2d');
         let width = canvas.width = window.innerWidth;
         let height = canvas.height = window.innerHeight;
         const horizon = height * 2 / 3;

         // ðŸ”¥ SUN CONFIGURATION
         const SUN_BASE_RADIUS = 120; // Doubled from original 60
         const GLOW_SCALE = 6; // Increased from 4
         let sunYOffset = 0; // Added for vertical movement
         const SUN_SPEED = 0.4; // Pixels per frame

         // ============================
         // STARFIELD (top half)
         // ============================
         const starCount = 200;
         let stars = [];
         let shootingStars = [];
         for (let i = 0; i < starCount; i++) {
             stars.push({
                 x: Math.random() * width,
                 y: Math.random() * horizon,
                 size: Math.random() * 1.5 + 0.5,
                 speed: Math.random() * 0.2 + 0.05,
                 opacity: Math.random() * 0.5 + 0.5
             });
         }

         function spawnShootingStar() {
             if (shootingStars.length < 1 && Math.random() < 0.005) {
                 shootingStars.push({
                     x: Math.random() * width,
                     y: Math.random() * horizon * 0.5,
                     len: Math.random() * 80 + 80,
                     speed: Math.random() * 10 + 10,
                     angle: Math.PI / 4,
                     life: 0,
                     maxLife: 30 + Math.random() * 30
                 });
             }
         }

         function updateStars() {
             for (let star of stars) {
                 star.x -= star.speed;
                 if (star.x < 0) star.x = width;
             }
         }

         function updateShootingStars() {
             for (let i = shootingStars.length - 1; i >= 0; i--) {
                 let s = shootingStars[i];
                 s.x += s.speed * Math.cos(s.angle);
                 s.y += s.speed * Math.sin(s.angle);
                 s.life++;
                 if (s.life > s.maxLife) {
                     shootingStars.splice(i, 1);
                 }
             }
         }

         function drawStars() {
             ctx.fillStyle = "white";
             for (let star of stars) {
                 ctx.globalAlpha = star.opacity;
                 ctx.beginPath();
                 ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                 ctx.fill();
             }
             ctx.globalAlpha = 1;
         }

         function drawShootingStars() {
             ctx.strokeStyle = "white";
             ctx.lineWidth = 2;
             for (let s of shootingStars) {
                 ctx.beginPath();
                 ctx.moveTo(s.x, s.y);
                 ctx.lineTo(s.x - s.len * Math.cos(s.angle), s.y - s.len * Math.sin(s.angle));
                 ctx.stroke();
             }
         }


         // =======================[UPDATED SUN SYSTEM]=======================
         function updateSunPosition() {
             sunYOffset += SUN_SPEED; // Gradually lower the sun
         }

         function drawSun() {
             const sunX = width / 2;
             const sunY = horizon + sunYOffset; // ðŸ”¥ Now moves downward

             // ðŸ”¥ Enhanced glow with dynamic positioning
             const gradient = ctx.createRadialGradient(
                 sunX, sunY, SUN_BASE_RADIUS * 0.3,
                 sunX, sunY, SUN_BASE_RADIUS * GLOW_SCALE
             );
             gradient.addColorStop(0, 'rgba(255, 69, 0, 0.5)');
             gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.25)');
             gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

             // Draw glow first
             ctx.fillStyle = gradient;
             ctx.beginPath();
             ctx.rect(0, 0, width, height); // ðŸ”¥ Full height glow
             ctx.fill();

             // Main sun body (now larger)
             ctx.beginPath();
             ctx.arc(sunX, sunY, SUN_BASE_RADIUS, Math.PI, 2 * Math.PI);
             let sunGradient = ctx.createLinearGradient(0, sunY - SUN_BASE_RADIUS, 0, sunY);
             sunGradient.addColorStop(0, "#FF4500");
             sunGradient.addColorStop(1, "#FFD700");
             ctx.fillStyle = sunGradient;
             ctx.fill();

             // Sun details (scaled appropriately)
             const numLines = 8; // ðŸ”¥ Increased lines for bigger sun
             for (let i = 0; i < numLines; i++) {
                 let lineY = sunY - SUN_BASE_RADIUS + (i + 1) * (SUN_BASE_RADIUS / (numLines + 1));
                 ctx.beginPath();
                 let dx = Math.sqrt(SUN_BASE_RADIUS ** 2 - (sunY - lineY) ** 2);
                 ctx.moveTo(sunX - dx, lineY);
                 ctx.lineTo(sunX + dx, lineY);
                 ctx.lineWidth = 1 + (i / numLines) * 5; // ðŸ”¥ Thicker lines
                 ctx.strokeStyle = "rgba(0,0,0,0.3)";
                 ctx.stroke();
             }
         }

         // ============================
         // GRID SYSTEM WITH STABLE RELIEF
         // ============================
         const numGridLines = 40;
         const numGridCols = 30;
         const gridSpeed = 0.08;
         let gridOffset = 0;

         // Relief pattern storage
         const reliefMap = Array(numGridCols + 1).fill().map(() =>
             Array(numGridLines).fill().map(() =>
                 Math.random() < 0.12 ? Math.random() * 35 + 15 : 0
             )
         );

         function drawGrid() {
             ctx.strokeStyle = "#00FFFF";
             ctx.lineWidth = 1;

             // Calculate horizontal positions with seamless wrap
             const horizontalPositions = Array(numGridLines).fill().map((_, i) => {
                 const t = (i + gridOffset) % numGridLines;
                 const perspective = t / numGridLines;
                 return {
                     yBase: horizon + (height - horizon) * Math.pow(perspective, 2),
                     t: perspective
                 };
             });

             // Draw vertical lines with coordinated relief and fading
             const roadHalfWidth = 180;
             for (let col = 0; col <= numGridCols; col++) {
                 const xNorm = col / numGridCols;
                 const vanishX = width/2 - roadHalfWidth + xNorm * 2 * roadHalfWidth;

                 let lastPoint = null;

                 horizontalPositions.forEach((pos, row) => {
                     const lift = reliefMap[col][row];
                     const y = pos.yBase - lift;
                     const x = xNorm * width + (vanishX - xNorm * width) * (1 - pos.t);

                     if (row === 0) {
                         lastPoint = { x, y };
                     } else {
                         // Calculate alpha based on current row's t
                         let baseAlpha;
                         if (pos.t < 0.1) {
                             baseAlpha = 0;
                         } else if (pos.t < 0.3) {
                             baseAlpha = (pos.t - 0.1) / 0.2;
                         } else if (pos.t <= 0.7) {
                             baseAlpha = 1;
                         } else if (pos.t < 0.9) {
                             baseAlpha = 1 - (pos.t - 0.7) / 0.2;
                         } else {
                             baseAlpha = 0;
                         }
                         ctx.globalAlpha = baseAlpha * 0.6;

                         const cpX = (lastPoint.x + x) / 2;
                         const cpY = (lastPoint.y + y) / 2 - lift * 0.4;

                         ctx.beginPath();
                         ctx.moveTo(lastPoint.x, lastPoint.y);
                         ctx.quadraticCurveTo(cpX, cpY, x, y);
                         ctx.stroke();

                         lastPoint = { x, y };
                     }
                 });
             }

             // Draw horizontal lines with connected relief and fading
             horizontalPositions.forEach((pos, row) => {
                 // Calculate alpha based on row's t
                 let baseAlpha;
                 if (pos.t < 0.1) {
                     baseAlpha = 0;
                 } else if (pos.t < 0.3) {
                     baseAlpha = (pos.t - 0.1) / 0.2;
                 } else if (pos.t <= 0.7) {
                     baseAlpha = 1;
                 } else if (pos.t < 0.9) {
                     baseAlpha = 1 - (pos.t - 0.7) / 0.2;
                 } else {
                     baseAlpha = 0;
                 }
                 ctx.globalAlpha = baseAlpha * 0.6;

                 ctx.beginPath();
                 let lastX = null, lastY = null;

                 for (let col = 0; col <= numGridCols; col++) {
                     const xNorm = col / numGridCols;
                     const vanishX = width/2 - roadHalfWidth + xNorm * 2 * roadHalfWidth;
                     const lift = reliefMap[col][row];
                     const y = pos.yBase - lift;
                     const x = xNorm * width + (vanishX - xNorm * width) * (1 - pos.t);

                     if (col === 0) {
                         ctx.moveTo(x, y);
                         lastX = x;
                         lastY = y;
                     } else {
                         const cpX = (lastX + x) / 2;
                         const cpY = (lastY + y) / 2 - lift * 0.3;
                         ctx.quadraticCurveTo(cpX, cpY, x, y);
                         lastX = x;
                         lastY = y;
                     }
                 }
                 ctx.stroke();
             });

             ctx.globalAlpha = 1;
         }

       // =======================[UPDATED ANIMATION LOOP]===================
         function update() {
             gridOffset += gridSpeed;
             if (gridOffset > numGridLines) gridOffset = 0;
             updateStars();
             updateShootingStars();
             spawnShootingStar();
             updateSunPosition(); // ðŸ”¥ Added sun movement
         }

         function draw() {
             ctx.clearRect(0, 0, width, height);

             // Draw starfield elements
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, 0, width, horizon);
             drawStars();
             drawShootingStars();

             // Draw sun system
             drawSun(); // ðŸ”¥ Now includes glow and sun together

             // Draw ground and grid
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, horizon, width, height - horizon);
             drawGrid();
         }

         // ============================
         // NEW: SUN GLOW GRADIENT
         // ============================
         function drawSunGlow() {
             const sunX = width / 2;
             const sunY = horizon;
             const sunRadius = 60;

             // Create radial gradient
             const gradient = ctx.createRadialGradient(
                 sunX, sunY, sunRadius * 0.3,
                 sunX, sunY, sunRadius * 4
             );
             gradient.addColorStop(0, 'rgba(255, 69, 0, 0.4)');
             gradient.addColorStop(0.7, 'rgba(255, 215, 0, 0.2)');
             gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

             // Draw gradient
             ctx.fillStyle = gradient;
             ctx.beginPath();
             ctx.rect(0, 0, width, horizon);
             ctx.fill();
         }

         // ============================
         // MODIFIED DRAW FUNCTION
         // ============================
         function draw() {
             ctx.clearRect(0, 0, width, height);

             // Draw black background
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, 0, width, horizon);

             // Draw sun glow first
             drawSunGlow();

             // Then draw stars and shooting stars
             drawStars();
             drawShootingStars();

             // Draw original sun on top
             drawSun();

             // Draw lower half and grid
             ctx.fillStyle = "#000000";
             ctx.fillRect(0, horizon, width, height - horizon);
             drawGrid();
         }

         function loop() {
             update();
             draw();
             requestAnimationFrame(loop);
         }

         loop();

         window.addEventListener('resize', () => {
             width = canvas.width = window.innerWidth;
             height = canvas.height = window.innerHeight;
         });
        </script>
    </body>
</html>
