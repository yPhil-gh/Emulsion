<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>80s Sunset Scene with Relief</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
   const canvas = document.getElementById('canvas');
   const ctx = canvas.getContext('2d');
   let width = canvas.width = window.innerWidth;
   let height = canvas.height = window.innerHeight;
   const horizon = height * 2 / 3;

   // ============================
   // STARFIELD (top half)
   // ============================
   const starCount = 200;
   let stars = [];
   let shootingStars = [];
   for (let i = 0; i < starCount; i++) {
       stars.push({
           x: Math.random() * width,
           y: Math.random() * horizon,
           size: Math.random() * 1.5 + 0.5,
           speed: Math.random() * 0.2 + 0.05,
           opacity: Math.random() * 0.5 + 0.5
       });
   }

   function spawnShootingStar() {
       if (shootingStars.length < 1 && Math.random() < 0.005) {
           shootingStars.push({
               x: Math.random() * width,
               y: Math.random() * horizon * 0.5,
               len: Math.random() * 80 + 80,
               speed: Math.random() * 10 + 10,
               angle: Math.PI / 4,
               life: 0,
               maxLife: 30 + Math.random() * 30
           });
       }
   }

   function updateStars() {
       for (let star of stars) {
           star.x -= star.speed;
           if (star.x < 0) star.x = width;
       }
   }

   function updateShootingStars() {
       for (let i = shootingStars.length - 1; i >= 0; i--) {
           let s = shootingStars[i];
           s.x += s.speed * Math.cos(s.angle);
           s.y += s.speed * Math.sin(s.angle);
           s.life++;
           if (s.life > s.maxLife) {
               shootingStars.splice(i, 1);
           }
       }
   }

   function drawStars() {
       ctx.fillStyle = "white";
       for (let star of stars) {
           ctx.globalAlpha = star.opacity;
           ctx.beginPath();
           ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
           ctx.fill();
       }
       ctx.globalAlpha = 1;
   }

   function drawShootingStars() {
       ctx.strokeStyle = "white";
       ctx.lineWidth = 2;
       for (let s of shootingStars) {
           ctx.beginPath();
           ctx.moveTo(s.x, s.y);
           ctx.lineTo(s.x - s.len * Math.cos(s.angle), s.y - s.len * Math.sin(s.angle));
           ctx.stroke();
       }
   }

   // ============================
   // SETTING SUN (at the horizon)
   // ============================
   function drawSun() {
       const sunRadius = 60;
       const sunX = width / 2;
       const sunY = horizon;
       ctx.beginPath();
       ctx.arc(sunX, sunY, sunRadius, Math.PI, 2 * Math.PI);
       let gradient = ctx.createLinearGradient(0, sunY - sunRadius, 0, sunY);
       gradient.addColorStop(0, "#FF4500");
       gradient.addColorStop(1, "#FFD700");
       ctx.fillStyle = gradient;
       ctx.fill();
       const numLines = 6;
       for (let i = 0; i < numLines; i++) {
           let lineY = sunY - sunRadius + (i + 1) * (sunRadius / (numLines + 1));
           ctx.beginPath();
           let dx = Math.sqrt(sunRadius * sunRadius - Math.pow(sunY - lineY, 2));
           ctx.moveTo(sunX - dx, lineY);
           ctx.lineTo(sunX + dx, lineY);
           ctx.lineWidth = 1 + (i / numLines) * 3;
           ctx.strokeStyle = "rgba(0,0,0,0.3)";
           ctx.stroke();
       }
   }

// ============================
   // STABLE PERSPECTIVE GRID
   // ============================
   let gridOffset = 0;
   const numGridLines = 30;
   const numGridCols = 20;
   const gridSpeed = 0.05;
   const reliefMap = [];
   const visibleGridLines = 25; // Only draw top 25 of 30 lines to prevent bottom flicker

   function createRelief() {
       for (let i = 0; i <= numGridCols; i++) {
           reliefMap[i] = [];
           for (let j = 0; j < visibleGridLines; j++) { // Only populate visible lines
               reliefMap[i][j] = Math.random() < 0.15 ? Math.random() * 30 + 15 : 0;
           }
       }
   }

   function drawGrid() {
       ctx.strokeStyle = "#00FFFF";
       ctx.lineWidth = 1;
       ctx.globalAlpha = 0.6;

       const horizontalYs = [];
       for (let i = 0; i < visibleGridLines; i++) { // Only process visible lines
           let t = (i + gridOffset) % numGridLines;
           let perspective = t / numGridLines;
           let y = horizon + (height - horizon) * Math.pow(perspective, 2);
           horizontalYs.push(y);
       }

       const roadHalfWidth = 150;

       // Draw vertical lines with truncated bottoms
       for (let i = 0; i <= numGridCols; i++) {
           const xBottom = (i / numGridCols) * width;
           const f = i / numGridCols;
           const vanishX = (1 - f) * (width / 2 - roadHalfWidth) + f * (width / 2 + roadHalfWidth);

           ctx.beginPath();
           let lastY = horizon + (height - horizon) * Math.pow((visibleGridLines-1)/numGridLines, 2);
           let lastX = xBottom + (vanishX - xBottom) * (1 - ((visibleGridLines-1)/numGridLines));

           for (let j = 0; j < horizontalYs.length; j++) {
               const baseY = horizontalYs[j];
               const lift = reliefMap[i][j];
               const y = baseY - lift;
               const t = (baseY - horizon) / (height - horizon);
               const x = xBottom + (vanishX - xBottom) * (1 - t);

               if (j === 0) {
                   ctx.moveTo(x, y);
               } else {
                   const cpX = (lastX + x) / 2;
                   const cpY = (lastY + y) / 2 - lift * 0.5;
                   ctx.quadraticCurveTo(cpX, cpY, x, y);
               }

               lastX = x;
               lastY = y;
           }
           ctx.stroke();
       }

       // Draw horizontal lines without the bottom 5 lines
       for (let j = 0; j < horizontalYs.length - 5; j++) { // Skip last 5 lines
           const baseY = horizontalYs[j];
           ctx.beginPath();

           for (let i = 0; i <= numGridCols; i++) {
               const lift = reliefMap[i][j];
               const y = baseY - lift;
               const f = i / numGridCols;
               const vanishX = (1 - f) * (width / 2 - roadHalfWidth) + f * (width / 2 + roadHalfWidth);
               const t = (baseY - horizon) / (height - horizon);
               const x = (i / numGridCols) * width + (vanishX - (i / numGridCols) * width) * (1 - t);

               if (i === 0) {
                   ctx.moveTo(x, y);
               } else {
                   const prevX = (i - 1)/numGridCols * width + (vanishX - ((i - 1)/numGridCols * width)) * (1 - t);
                   const cpX = (prevX + x) / 2;
                   const cpY = (y + y) / 2 - lift * 0.3;
                   ctx.quadraticCurveTo(cpX, cpY, x, y);
               }
           }
           ctx.stroke();
       }

       ctx.globalAlpha = 1;
   }

   // ============================
   // ANIMATION LOOP
   // ============================
   function update() {
       gridOffset += gridSpeed;
       if (gridOffset > numGridLines) gridOffset = 0;
       updateStars();
       updateShootingStars();
       spawnShootingStar();
   }

   function draw() {
       ctx.clearRect(0, 0, width, height);
       ctx.fillStyle = "#000000";
       ctx.fillRect(0, 0, width, horizon);
       drawStars();
       drawShootingStars();
       drawSun();
       ctx.fillStyle = "#000040";
       ctx.fillRect(0, horizon, width, height - horizon);
       drawGrid();
   }

   function loop() {
       update();
       draw();
       requestAnimationFrame(loop);
   }

   // Initialize relief map and start animation
   createRelief();
   loop();

   window.addEventListener('resize', () => {
       width = canvas.width = window.innerWidth;
       height = canvas.height = window.innerHeight;
       createRelief(); // Regenerate relief map on resize
   });
  </script>
</body>
</html>
